{"version":3,"sources":["sortingAlgos/sortingAlgos.js","SortingVisualizer/sortingVisualizer.jsx","App.js","serviceWorker.js","index.js"],"names":["quickSort","array","animations","quickSortHelper","start","end","index","low","high","pivot","i","j","animation","comparison","swap","secondCompare","push","animatedSwap","partition","length","mergeSort","mergeSortHelper","mid","Math","round","position","next","k","temp","merge","SortingVisualiser","props","MIN_ARR_VAL","MAX_ARR_VAL","disabled","state","animationSpeed","arrayLength","this","makeArray","prevProps","prevState","document","getElementById","value","setState","floor","random","arr","getRangedRandNum","ANIMATION_SPEED","arrayBars","getElementsByClassName","setTimeout","undefined","sorted","style","backgroundColor","height","animate","swapped","sortingAlgos","current","parent","left","right","imgHeight","window","innerHeight","imgWidth","innerWidth","shortid","require","className","map","key","generate","width","color","fontSize","onClick","bubbleSort","cocktailSort","insertionSort","heapSort","type","min","max","id","onChange","refresh","React","Component","App","Boolean","location","hostname","match","ReactDOM","render","StrictMode","navigator","serviceWorker","ready","then","registration","unregister","catch","error","console","message"],"mappings":"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","file":"static/js/main.63f1c11c.chunk.js","sourcesContent":["export function bubbleSort(array) {\n    const animations = [];\n    var i = 0;\n    while (true) {\n        var swapped = false;\n        // compare adjacent cells\n        for (let j = 0; j < array.length - 1 - i; j++) {\n            const animation = {};\n            animation.comparison = [j, j+1];\n            if (array[j] > array[j+1]) {\n                animation.swap = [j, j+1]\n                swap(array, j, j+1);\n                swapped = true;\n            }\n            animations.push(animation);\n        }\n        // no swaps -> sorted \n        if (!swapped) {\n            break;\n        } \n        i++;\n   \n    }\n    const animation = {};\n    animation.sorted = 1;\n    animations.push(animation);\n    return animations;\n     \n}\n\nexport function cocktailSort(array) {\n    const animations = [];\n    var i = 0;\n    while (true) {\n        var swapped = false;\n        // compare adjacent cells\n        var j = i-1;\n        while (j++ < array.length - 2 - i) {\n            const animation = {};\n            animation.comparison = [j, j+1];\n            if (array[j] > array[j+1]) {\n                animation.swap = [j, j+1]\n                swap(array, j, j+1);\n                swapped = true;\n            }\n            animations.push(animation);\n        }\n        while (j-- > 1 + i) {\n            const animation = {};\n            animation.comparison = [j, j-1];\n            if (array[j] < array[j-1]) {\n                animation.swap = [j, j-1]\n                swap(array, j, j-1);\n                swapped = true;\n            }\n            animations.push(animation);\n        }\n        // no swaps -> sorted \n        if (!swapped) {\n            break;\n        } \n        i++;\n    }\n    const animation = {};\n    animation.sorted = 1;\n    animations.push(animation);\n    return animations;\n}\n\nexport function insertionSort(array) {\n    const animations = [];\n    for (let i = 1; i < array.length; i++) {\n        var current = array[i];\n        var j = i - 1;\n\n        // scan down the array until an insertion position is found for index, shifting each element > index up 1 position\n        while (array[j] > current && j >= 0) { \n            const animation = {};\n            animation.comparison = [j, j+1];\n            animation.swap = [j, j+1];\n            animations.push(animation);\n            array[j+1] = array[j--];\n            \n        }\n        // note no animation here \n        // animation suggests that each element is swapped with index until insertion, thus this last step in superfluous\n        // in reality, each element overrides the next until insertion, thus the index needs to be placed \n        // this is more efficient as only one element has to be accessed to override, as opposed to two needed for swapping\n        array[j+1] = current;\n    }\n    const animation = {};\n    animation.sorted = 1;\n    animations.push(animation);\n    return animations;\n}\n\n\nexport function quickSort(array) {\n    const animations = [];\n    quickSortHelper(animations, array, 0, array.length-1);\n    const animation = {};\n    animation.sorted = 1;\n    animations.push(animation);\n    return animations;\n}\n\nfunction quickSortHelper(animations, array, start, end) {\n    // one or less element -> no need to partition\n    if (start < end) {\n        const index = partition(animations, array, start, end);\n        // sort smaller subarray first to minimize nested calls\n        if (index < (start+end)/2) {\n            quickSortHelper(animations, array, start, index-1);\n            quickSortHelper(animations, array, index+1, end);\n        }\n        else {\n            quickSortHelper(animations, array, index+1, end);\n            quickSortHelper(animations, array, start, index-1);\n        } \n        \n    }\n\n}\n\nfunction partition(animations, array, low, high) {\n    // use last element as pivot\n    const pivot = array[high];\n    let i = low - 1;\n\n    for (let j = low; j < high; j++) {\n        const animation = {};\n        animation.comparison = [j, high];\n        if (array[j] < pivot) {\n            swap(array, ++i, j);\n            animation.secondCompare = i;\n            animation.swap = [i, j];\n        }\n        animations.push(animation);\n    }\n    animatedSwap(animations, array, i+1, high);\n    return i+1;\n}\n\n\nexport function mergeSort(array) {\n    const animations = [];\n    mergeSortHelper(animations, array, 0, array.length-1);\n    const animation = {};\n    animation.sorted = 1;\n    animations.push(animation);\n    return animations;\n}\n\n\n\nfunction mergeSortHelper(animations, array, low, high) {\n    if (low < high) {\n        const mid = Math.round((low+high)/2);\n        mergeSortHelper(animations, array, low, mid-1);\n        mergeSortHelper(animations, array, mid, high);\n        merge(animations, array, low, mid, high);\n    }\n}\n\n// merging low -> mid-1 and mid -> high sub-arrays\nfunction merge(animations, array, low, mid, high) {\n\n    // tracks the current index (position[i]) of an element with starting index i\n    const position = []\n\n    var i = low\n    var next = low\n    var j = mid\n\n    // fill position array with starting indicies (0, 1, 2...)\n    for (var k = low; k < mid; k++) {\n        position[k] = k;\n    }\n\n    while ((i < mid) && (next < high)) {\n        if ((j > high) || (array[position[i]] <= array[j])) {\n            if (next !== position[i]) {\n                animatedSwap(animations, array, next, position[i]);\n                // record swap indicies in position array \n                position[position[i]] = position[next];\n                position[position[next]] = position[i];\n            }\n            i++; \n            next++;\n        }\n        else {\n            animatedSwap(animations, array, next, j);\n            // record swap indicies in position array\n            var temp = position[next];\n            position[position[next++]] = j;\n            position[j++] = temp;\n        }\n    }\n}\n\nexport function heapSort(array) {\n    const animations = [];\n    // Reform array into a heap \n    for (let i = 0; i < array.length; i++) {\n        // Upheap i\n         while (i > 0) {\n            var parent = Math.floor((i-1)/2);\n            const animation = {};\n            animation.comparison = [i, parent];\n            if (array[i] > array[parent]) {\n                swap(array, i, parent);\n                animation.swap = [i, parent];\n                animations.push(animation);\n                i = parent;\n            }\n            else {\n                animations.push(animation);\n                break;\n            }\n        }\n    }\n\n    // Iteratively place the smallest ID at the 'back' of the array, \n    // where the 'end' of the unsorted array is defined by j\n    for (let j = array.length-1; j > 0; j--) {\n        // Replace root with last node\n        animatedSwap(animations, array, 0, j);\n        var current = 0;\n        // Downheap from root (current)\n        while (true) {\n            let left = (current*2) + 1;\n            let right = left + 1;\n            // No left child -> leaf + leaf\n            if (left >= j) { \n                break;\n            }\n            // No right child -> left child + leaf\n            else if (right >= j) {\n                const animation = {};\n                animation.comparison = [current, left]\n                if (array[current] < array[left]) {\n                    swap(array, current, left);\n                    animation.swap = [current, left];\n                }\n                animations.push(animation);\n                break;     \n            }\n            // Current has both children\n            else if (array[current] < array[left] || array[current] < array[right]) {\n                // left > right\n                if (array[left] > array[right]) { \n                    animatedSwap(animations, array, current, left);\n                    current = left;\n                }\n                // right >= left\n                else { \n                    animatedSwap(animations, array, current, right);\n                    current = right;\n                }     \n            }\n            // Both children >= current -> sorted\n            else { \n                break;\n            }\n        }\n    }\n    const animation = {};\n    animation.sorted = 1;\n    animations.push(animation);\n    return animations;\n}\n\n\nfunction swap(array, i, j) {\n    var temp = array[i];\n    array[i] = array[j];\n    array[j] = temp;\n}\n\nfunction animatedSwap(animations, array, i, j) {\n    // perform swap\n    swap(array,i,j);\n\n    // record swap in animations \n    const animation = {};\n    animation.comparison = [i, j];\n    animation.swap = [i, j];\n    animations.push(animation);\n}\n\n\n","import React from './../../node_modules/react';\r\nimport './sortingVisualizer.css';\r\nimport  * as sortingAlgos from '../sortingAlgos/sortingAlgos.js';\r\n\r\n\r\nexport default class SortingVisualiser extends React.Component {\r\n    // min/max value for an element in the array\r\n    MIN_ARR_VAL = 10;\r\n    MAX_ARR_VAL = 200;\r\n\r\n    // If true, disables rendering until false\r\n    // cannot be part of state as it would require rendering to update \r\n    disabled = false;\r\n\r\n    constructor(props) {\r\n        super(props);\r\n\r\n        this.state = {\r\n            // Main array \r\n            array: [],\r\n            // Animation speed of sorts\r\n            animationSpeed: 40,\r\n            // Main array length\r\n            arrayLength: 51,\r\n        };\r\n    }\r\n\r\n    // Generate array when first loading site\r\n    componentDidMount() {\r\n        this.makeArray();\r\n    }\r\n\r\n    componentDidUpdate(prevProps, prevState) {\r\n        // eslint-disable-next-line\r\n        if (this.disabled == false) {\r\n            // If the array length slider has been moved, update \r\n            // eslint-disable-next-line\r\n            if (prevState.arrayLength != document.getElementById(\"arrayLength\").value) {\r\n                this.setState({arrayLength: document.getElementById(\"arrayLength\").value})\r\n                // only make array once state is updated  \r\n                // eslint-disable-next-line\r\n                if (this.state.arrayLength == document.getElementById(\"arrayLength\").value) {\r\n                    this.makeArray();\r\n                }\r\n            }\r\n            // eslint-disable-next-line\r\n            if ((100 - prevState.animationSpeed) != document.getElementById(\"animationSpeed\").value) {\r\n                this.setState({animationSpeed: (100 - document.getElementById(\"animationSpeed\").value)})\r\n            }\r\n        }\r\n    }\r\n\r\n\r\n    // Generates a random number between two ranges \r\n    getRangedRandNum() {\r\n        return Math.floor(Math.random() * (this.MAX_ARR_VAL - this.MIN_ARR_VAL) + this.MIN_ARR_VAL);\r\n    }\r\n\r\n    makeArray() {\r\n        if (this.disabled !== true) {\r\n            // Creates an array which is used to update the state\r\n            const arr = [];\r\n\r\n            // Fills the array according to parameters\r\n            for (let i = 0; i < this.state.arrayLength; i++) {\r\n                arr.push(this.getRangedRandNum());\r\n            }\r\n            // Updates the state of the component with the new array\r\n            // {} used as 'arr' is an object \r\n            this.setState({array: arr});\r\n        }\r\n        \r\n    }\r\n\r\n    animate(animations, ANIMATION_SPEED) {\r\n\r\n        // creates an array of all \"array-bar\" objects\r\n        const arrayBars = document.getElementsByClassName('array-bar'); \r\n\r\n        // disable all actions until sorting complete\r\n        this.disabled = true;\r\n        setTimeout(() => {\r\n            this.disabled = false;\r\n        }, (animations.length + arrayBars.length) * ANIMATION_SPEED)\r\n\r\n        // Step through animations\r\n        for (let i = 0; i < animations.length; i++) {\r\n            const {comparison, swap, sorted} = animations[i];\r\n\r\n            // highlight array green when sorted\r\n            if (sorted !== undefined) {\r\n                for (let j = 0; j < arrayBars.length; j++) {\r\n                    setTimeout(() => {\r\n                        arrayBars[j].style.backgroundColor = 'green';\r\n                    }, (i+j) * ANIMATION_SPEED)\r\n                }\r\n                break;\r\n            }\r\n            \r\n            // highlight elements being compared in red\r\n            setTimeout(() => {\r\n                arrayBars[comparison[1]].style.backgroundColor = 'red';\r\n                arrayBars[comparison[0]].style.backgroundColor = 'red';              \r\n            }, i * ANIMATION_SPEED)\r\n\r\n            // If there is a swap, swap the height of the two bars\r\n            if (swap !== undefined) {\r\n                setTimeout(() => {\r\n                    const temp = arrayBars[swap[0]].style.height;\r\n                    arrayBars[swap[0]].style.height = arrayBars[swap[1]].style.height;\r\n                    arrayBars[swap[1]].style.height = temp;\r\n                }, i * ANIMATION_SPEED)\r\n            }\r\n            // Once the comparison has been made, return the elements' colour to blue\r\n            setTimeout(() => {   \r\n                arrayBars[comparison[1]].style.backgroundColor = 'blue';\r\n                arrayBars[comparison[0]].style.backgroundColor = 'blue';\r\n            }, (i+1) * ANIMATION_SPEED)   \r\n        } \r\n    }\r\n\r\n    // Animate the bubble sort method\r\n    bubbleSort() {\r\n        // eslint-disable-next-line\r\n        if (this.disabled == false) this.animate(sortingAlgos.bubbleSort(this.state.array), this.state.animationSpeed);\r\n        \r\n    }\r\n\r\n    cocktailSort() {\r\n        // eslint-disable-next-line\r\n        if (this.disabled == false) this.animate(sortingAlgos.cocktailSort(this.state.array), this.state.animationSpeed);\r\n    }\r\n\r\n    // Animate the insertion sort method\r\n    insertionSort() {\r\n        // eslint-disable-next-line\r\n        if (this.disabled == false) this.animate(sortingAlgos.insertionSort(this.state.array), this.state.animationSpeed);\r\n\r\n    }\r\n\r\n    // Animate the quick sort method \r\n    quickSort() {\r\n        // eslint-disable-next-line\r\n        if (this.disabled == false) {\r\n\r\n            const ANIMATION_SPEED = this.state.animationSpeed;\r\n            const animations = sortingAlgos.quickSort(this.state.array);\r\n            // creates an array of all \"array-bar\" objects\r\n            const arrayBars = document.getElementsByClassName('array-bar'); \r\n\r\n            // disable all actions until sorting complete\r\n            this.disabled = true;\r\n            setTimeout(() => {\r\n                this.disabled = false;\r\n            }, (animations.length + arrayBars.length) * ANIMATION_SPEED)\r\n\r\n            \r\n            // Step through animations\r\n            for (let i = 0; i < animations.length; i++) {\r\n                const {comparison, swap, secondCompare, sorted} = animations[i];\r\n                \r\n                // highlight array green when sorted\r\n                if (sorted !== undefined) {\r\n                    for (let j = 0; j < arrayBars.length; j++) {\r\n                        setTimeout(() => {\r\n                            arrayBars[j].style.backgroundColor = 'green';\r\n                        }, (i+j) * ANIMATION_SPEED)\r\n                    }\r\n                    break;\r\n                }\r\n\r\n\r\n                // check for undefined animation (every animation with a swap must have a comparison)\r\n                if (comparison === undefined) {\r\n                    continue;\r\n                }\r\n\r\n                // highlight elements being compared in red\r\n                setTimeout(() => {\r\n                    arrayBars[comparison[1]].style.backgroundColor = 'lime';\r\n                    arrayBars[comparison[0]].style.backgroundColor = 'red';\r\n                    if (secondCompare !== undefined) {\r\n                        arrayBars[secondCompare].style.backgroundColor = 'red';\r\n                    }\r\n                    \r\n                }, i * ANIMATION_SPEED)\r\n\r\n                // If there is a swap, swap the height of the two bars\r\n                if (swap !== undefined) {\r\n                    setTimeout(() => {\r\n                        const temp = arrayBars[swap[0]].style.height;\r\n                        arrayBars[swap[0]].style.height = arrayBars[swap[1]].style.height;\r\n                        arrayBars[swap[1]].style.height = temp;\r\n                    }, i * ANIMATION_SPEED)\r\n                }\r\n                // Once the comparison has been made, return the elements' colour to blue\r\n                setTimeout(() => {   \r\n                    arrayBars[comparison[1]].style.backgroundColor = 'blue';\r\n                    arrayBars[comparison[0]].style.backgroundColor = 'blue';\r\n                    if (secondCompare !== undefined) {\r\n                        arrayBars[secondCompare].style.backgroundColor = 'blue';\r\n                    }\r\n                }, (i+1) * ANIMATION_SPEED)     \r\n            }\r\n        }\r\n    }\r\n\r\n    mergeSort() {\r\n        // eslint-disable-next-line\r\n        if (this.disabled == false) this.animate(sortingAlgos.mergeSort(this.state.array), this.state.animationSpeed);\r\n    }\r\n\r\n    heapSort() {\r\n        // eslint-disable-next-line\r\n        if (this.disabled == false) this.animate(sortingAlgos.heapSort(this.state.array), this.state.animationSpeed);\r\n    }\r\n\r\n\r\n    /*\r\n    arraysEqual(a, b) {\r\n        if (a === b) return true;\r\n        if (a == null || b == null) return false;\r\n        if (a.length !== b.length) return false;\r\n      \r\n        // If you don't care about the order of the elements inside\r\n        // the array, you should sort both arrays here.\r\n        // Please note that calling sort on an array will modify that array.\r\n        // you might want to clone your array first.\r\n      \r\n        for (var i = 0; i < a.length; ++i) {\r\n          if (a[i] !== b[i]) return false;\r\n        }\r\n        return true;\r\n    }\r\n\r\n    test() {\r\n        var bool = true\r\n        for (let i = 0; i < 1000; i++) {\r\n            setTimeout(() => {\r\n                this.makeArray()\r\n                const test = sortingAlgos.heapSort(this.state.array)\r\n                const sorted = this.state.array.sort(function(a, b){return a-b});\r\n                bool = bool && this.arraysEqual(test, sorted);\r\n            }, i * 2)\r\n        }\r\n        setTimeout (() => {\r\n            console.log(bool)\r\n        }, 2000)\r\n    }\r\n    */\r\n\r\n    refresh() {\r\n        // eslint-disable-next-line\r\n        if (this.disabled == false) this.setState({})\r\n    }\r\n    \r\n\r\n    render() {\r\n\r\n        // Get the array & array length from the state \r\n        const {array, arrayLength} = this.state;\r\n\r\n        // Get the dimensions of the current window\r\n        // Allows for image resizing \r\n        let imgHeight = window.innerHeight;\r\n        let imgWidth = window.innerWidth;\r\n\r\n        // used to generate ‘short non-sequential url-friendly unique id(s)’ for array-bar keys \r\n        // https://www.npmjs.com/package/shortid\r\n        const shortid = require('shortid')\r\n\r\n        return (\r\n            // Store array-bars in array-container\r\n                // Style each array-bar, using: - value for relative height\r\n                //                              - imgHeight for the height range of the bars \r\n                //                              - imgWidth for bar width\r\n            <div className=\"border\">\r\n                \r\n                <div className=\"array-container\"> \r\n                    {array.map((value) => (\r\n                        <div className=\"array-bar\"\r\n                            // need a unique key - using index may display wrong data when animating and 'value' is not necessarily unique\r\n                            // https://medium.com/@robinpokorny/index-as-a-key-is-an-anti-pattern-e0349aece318\r\n                            key = {shortid.generate()}\r\n                            style = {{\r\n                                height: `${value*((0.7 * imgHeight)/this.MAX_ARR_VAL)}px`, // account for other ui taking window space\r\n                                width: `${((0.8*imgWidth-2*(arrayLength-1))/arrayLength)}px`, // account for margins \r\n                                backgroundColor: 'blue'\r\n                            }}                                             \r\n                        ></div>\r\n                    ))}\r\n                </div>\r\n\r\n                <div className=\"buttonContainer\">\r\n                    <body style={{color: \"white\", fontSize: \"150%\"}}>Sorting Methods:</body>\r\n                    <button className=\"btn\" onClick={() => this.bubbleSort()}>Bubble</button>\r\n                    <button className=\"btn\" onClick={() => this.cocktailSort()}>Cocktail</button>\r\n                    <button className=\"btn\" onClick={() => this.insertionSort()}>Insertion</button>\r\n                    <button className=\"btn\" onClick={() => this.quickSort()}>Quick</button>\r\n                    <button className=\"btn\" onClick={() => this.mergeSort()}>Merge</button>\r\n                    <button className=\"btn\" onClick={() => this.heapSort()}>Heap</button>\r\n                </div>\r\n                \r\n                <div className=\"leftButtonContainer\">\r\n                <button className=\"btn\" onClick={() => this.makeArray()}>Generate</button>\r\n                </div>\r\n\r\n                <div className=\"rightSlideContainer\">\r\n                    <body style={{color: \"white\", fontSize: \"3vh\"}}>Animation Speed</body>\r\n                    <input type=\"range\" min=\"1\" max=\"99\" className=\"slider\" id=\"animationSpeed\" onChange={() => this.refresh()}/>\r\n                </div>\r\n\r\n                <div className=\"midSlideContainer\">\r\n                    <body style={{color: \"white\", fontSize: \"3vh\"}}>Array Length: {this.state.arrayLength}</body>\r\n                    <input type=\"range\" min=\"1\" max=\"200\" className=\"slider\" id=\"arrayLength\" onChange={() => this.refresh()}/>\r\n                </div>\r\n            </div>\r\n        );\r\n    }\r\n\r\n    \r\n    \r\n    \r\n}\r\n","import React from 'react';\nimport './App.css';\nimport SortingVisualizer from './SortingVisualizer/sortingVisualizer';\n\nfunction App() {\n  return (\n    <div className=\"App\">\n      <SortingVisualizer></SortingVisualizer>\n    </div>\n  );\n}\n\nexport default App;\n","// This optional code is used to register a service worker.\n// register() is not called by default.\n\n// This lets the app load faster on subsequent visits in production, and gives\n// it offline capabilities. However, it also means that developers (and users)\n// will only see deployed updates on subsequent visits to a page, after all the\n// existing tabs open on the page have been closed, since previously cached\n// resources are updated in the background.\n\n// To learn more about the benefits of this model and instructions on how to\n// opt-in, read https://bit.ly/CRA-PWA\n\nconst isLocalhost = Boolean(\n  window.location.hostname === 'localhost' ||\n    // [::1] is the IPv6 localhost address.\n    window.location.hostname === '[::1]' ||\n    // 127.0.0.0/8 are considered localhost for IPv4.\n    window.location.hostname.match(\n      /^127(?:\\.(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)){3}$/\n    )\n);\n\nexport function register(config) {\n  if (process.env.NODE_ENV === 'production' && 'serviceWorker' in navigator) {\n    // The URL constructor is available in all browsers that support SW.\n    const publicUrl = new URL(process.env.PUBLIC_URL, window.location.href);\n    if (publicUrl.origin !== window.location.origin) {\n      // Our service worker won't work if PUBLIC_URL is on a different origin\n      // from what our page is served on. This might happen if a CDN is used to\n      // serve assets; see https://github.com/facebook/create-react-app/issues/2374\n      return;\n    }\n\n    window.addEventListener('load', () => {\n      const swUrl = `${process.env.PUBLIC_URL}/service-worker.js`;\n\n      if (isLocalhost) {\n        // This is running on localhost. Let's check if a service worker still exists or not.\n        checkValidServiceWorker(swUrl, config);\n\n        // Add some additional logging to localhost, pointing developers to the\n        // service worker/PWA documentation.\n        navigator.serviceWorker.ready.then(() => {\n          console.log(\n            'This web app is being served cache-first by a service ' +\n              'worker. To learn more, visit https://bit.ly/CRA-PWA'\n          );\n        });\n      } else {\n        // Is not localhost. Just register service worker\n        registerValidSW(swUrl, config);\n      }\n    });\n  }\n}\n\nfunction registerValidSW(swUrl, config) {\n  navigator.serviceWorker\n    .register(swUrl)\n    .then(registration => {\n      registration.onupdatefound = () => {\n        const installingWorker = registration.installing;\n        if (installingWorker == null) {\n          return;\n        }\n        installingWorker.onstatechange = () => {\n          if (installingWorker.state === 'installed') {\n            if (navigator.serviceWorker.controller) {\n              // At this point, the updated precached content has been fetched,\n              // but the previous service worker will still serve the older\n              // content until all client tabs are closed.\n              console.log(\n                'New content is available and will be used when all ' +\n                  'tabs for this page are closed. See https://bit.ly/CRA-PWA.'\n              );\n\n              // Execute callback\n              if (config && config.onUpdate) {\n                config.onUpdate(registration);\n              }\n            } else {\n              // At this point, everything has been precached.\n              // It's the perfect time to display a\n              // \"Content is cached for offline use.\" message.\n              console.log('Content is cached for offline use.');\n\n              // Execute callback\n              if (config && config.onSuccess) {\n                config.onSuccess(registration);\n              }\n            }\n          }\n        };\n      };\n    })\n    .catch(error => {\n      console.error('Error during service worker registration:', error);\n    });\n}\n\nfunction checkValidServiceWorker(swUrl, config) {\n  // Check if the service worker can be found. If it can't reload the page.\n  fetch(swUrl, {\n    headers: { 'Service-Worker': 'script' },\n  })\n    .then(response => {\n      // Ensure service worker exists, and that we really are getting a JS file.\n      const contentType = response.headers.get('content-type');\n      if (\n        response.status === 404 ||\n        (contentType != null && contentType.indexOf('javascript') === -1)\n      ) {\n        // No service worker found. Probably a different app. Reload the page.\n        navigator.serviceWorker.ready.then(registration => {\n          registration.unregister().then(() => {\n            window.location.reload();\n          });\n        });\n      } else {\n        // Service worker found. Proceed as normal.\n        registerValidSW(swUrl, config);\n      }\n    })\n    .catch(() => {\n      console.log(\n        'No internet connection found. App is running in offline mode.'\n      );\n    });\n}\n\nexport function unregister() {\n  if ('serviceWorker' in navigator) {\n    navigator.serviceWorker.ready\n      .then(registration => {\n        registration.unregister();\n      })\n      .catch(error => {\n        console.error(error.message);\n      });\n  }\n}\n","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport './index.css';\nimport App from './App';\nimport * as serviceWorker from './serviceWorker';\n\nReactDOM.render(\n  <React.StrictMode>\n    <App />\n  </React.StrictMode>,\n  document.getElementById('root')\n);\n\n// If you want your app to work offline and load faster, you can change\n// unregister() to register() below. Note this comes with some pitfalls.\n// Learn more about service workers: https://bit.ly/CRA-PWA\nserviceWorker.unregister();\n"],"sourceRoot":""}